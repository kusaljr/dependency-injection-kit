import "reflect-metadata";

import * as chokidar from "chokidar";
import * as fs from "fs";
import * as path from "path";

const PROJECT_ROOT = path.join(__dirname, "..", "..");
const SERVICES_DIR = path.join(PROJECT_ROOT, "src");
const OUTPUT_FILE = path.join(PROJECT_ROOT, "lib/global/injection.ts");

// Define paths to exclude from scanning
const EXCLUDED_FILES = [
  path.join(PROJECT_ROOT, "src", "app.ts"), // Exclude the main app entry point
  path.join(PROJECT_ROOT, "lib", "utils", "generate-injection.ts"), // Exclude the generator itself
  OUTPUT_FILE, // Exclude the generated file
];

// Helper to check if a file should be excluded
function isExcluded(filePath: string): boolean {
  // Normalize paths for consistent comparison (especially on Windows)
  const normalizedFilePath = path.normalize(filePath);
  return EXCLUDED_FILES.some((excludedPath) =>
    normalizedFilePath.startsWith(path.normalize(excludedPath))
  );
}

const CONTAINER_RELATIVE_PATH = path
  .relative(
    path.dirname(OUTPUT_FILE),
    path.join(PROJECT_ROOT, "lib/global/container")
  )
  .replace(/\\/g, "/");

function findInjectableFiles(dir: string): string[] {
  let injectableFiles: string[] = [];
  const files = fs.readdirSync(dir);

  for (const file of files) {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      // Recursively search in subdirectories
      injectableFiles = injectableFiles.concat(findInjectableFiles(fullPath));
    } else if (file.endsWith(".ts") && !file.endsWith(".d.ts")) {
      // Only include .ts files (excluding .d.ts) that are NOT in the excluded list
      if (!isExcluded(fullPath)) {
        injectableFiles.push(fullPath);
      }
    }
  }
  return injectableFiles;
}

function generateInjectionFile() {
  const injectableFiles = findInjectableFiles(SERVICES_DIR);
  let imports: string[] = [];
  let registrations: string[] = [];
  let exports: string[] = [];

  registrations.push(
    `import { Container } from './${CONTAINER_RELATIVE_PATH}';`
  );
  registrations.push("");
  registrations.push("const container = Container.getInstance();");
  registrations.push("");

  for (const filePath of injectableFiles) {
    const absoluteFilePath = path.resolve(filePath);
    // Crucially, delete the cache *before* attempting to require
    // This helps ts-node pick up fresh changes, but won't solve initial "module not found" if app.ts imports injection.ts prematurely.
    delete require.cache[absoluteFilePath];

    try {
      // Temporarily bypass module cache for the file being processed if it was problematic
      // This is less about `require.cache` and more about ts-node's internal loader state.
      // The primary fix for "Cannot find module '../lib/global/injection'" in app.ts still relies on app.ts *not* importing it immediately.
      const module = require(absoluteFilePath);

      for (const key of Object.keys(module)) {
        const ClassRef = module[key];
        // Ensure it's a function (class) and has the injectable metadata
        if (
          typeof ClassRef === "function" &&
          Reflect.getMetadata("injectable", ClassRef)
        ) {
          const relativeImportPathToService = path
            .relative(path.dirname(OUTPUT_FILE), filePath.replace(/\.ts$/, ""))
            .replace(/\\/g, "/");

          imports.push(
            `import { ${key} } from '${relativeImportPathToService}';`
          );
          registrations.push(`container.register(${key});`);
          exports.push(
            `export const ${
              key.charAt(0).toLowerCase() + key.slice(1)
            } = container.resolve(${key});`
          );
        }
      }
    } catch (error) {
      console.error(`Error processing file ${filePath}:`, error);
      // If a file causes an error during processing (e.g., its own imports fail),
      // it means it likely isn't a simple injectable service that can be dynamically required like this,
      // or it has an unresolvable dependency within itself.
      // This is often where the `Cannot find module '../lib/global/injection'` from app.ts comes from.
    }
  }

  const fileContent = [
    `// This file is auto-generated by the injection watcher. Do not modify manually.`,
    `// It registers all @Injectable classes with the DI container.`,
    `// Generated on: ${new Date().toISOString()}`,
    "",
    ...imports.sort(), // Sort imports for consistency
    "",
    ...registrations,
    "",
    ...exports,
    "",
  ].join("\n");

  // Ensure the directory exists before writing the file
  fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
  fs.writeFileSync(OUTPUT_FILE, fileContent);
  console.log(
    `Generated ${OUTPUT_FILE} with ${exports.length} injectable services.`
  );
}

// --- Main Execution ---
function setupWatcher() {
  console.log(`Watching for changes in ${SERVICES_DIR}...`);

  // Configure chokidar to also ignore the excluded files
  const watcher = chokidar.watch(SERVICES_DIR, {
    ignored: [
      /(^|[\/\\])\../, // Ignore dotfiles
      ...EXCLUDED_FILES.map((p) => path.relative(SERVICES_DIR, p)), // Relative paths for chokidar's ignored option
    ],
    persistent: true,
    ignoreInitial: false,
  });

  watcher
    .on("add", (filePath) => {
      console.log(`File ${filePath} has been added.`);
      generateInjectionFile();
    })
    .on("change", (filePath) => {
      console.log(`File ${filePath} has been changed.`);
      generateInjectionFile();
    })
    .on("unlink", (filePath) => {
      console.log(`File ${filePath} has been removed.`);
      generateInjectionFile();
    })
    .on("error", (error) => console.error(`Watcher error: ${error}`))
    .on("ready", () =>
      console.log("Initial scan complete. Ready for changes.")
    );
}

// Initial generation run
generateInjectionFile();
// Set up the file watcher
setupWatcher();
