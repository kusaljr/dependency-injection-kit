import * as fs from "fs";
import { minimatch } from "minimatch";
import * as path from "path";
import "reflect-metadata";

const PROJECT_ROOT = path.join(__dirname, "..", "..");
const SERVICES_DIR = path.join(PROJECT_ROOT, "src");
const OPS_DIR = path.join(PROJECT_ROOT, "lib", "ops");
const OUTPUT_FILE = path.join(PROJECT_ROOT, "lib/global/injection.ts");

// Paths to exclude
const EXCLUDED_PATTERNS = [
  "**/*.spec.ts",
  "src/app.ts",
  "lib/utils/generate-injection.ts",
  "lib/global/injection.ts",
  "**/*.dto.ts",
];

function isExcluded(filePath: string): boolean {
  const relativePath = path
    .relative(PROJECT_ROOT, filePath)
    .replace(/\\/g, "/");
  return EXCLUDED_PATTERNS.some((pattern) => minimatch(relativePath, pattern));
}

const CONTAINER_RELATIVE_PATH = path
  .relative(
    path.dirname(OUTPUT_FILE),
    path.join(PROJECT_ROOT, "lib/global/container")
  )
  .replace(/\\/g, "/");

function findInjectableFiles(dir: string): string[] {
  let injectableFiles: string[] = [];
  if (!fs.existsSync(dir)) return injectableFiles;

  const files = fs.readdirSync(dir);

  for (const file of files) {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      injectableFiles = injectableFiles.concat(findInjectableFiles(fullPath));
    } else if (
      (file.endsWith(".ts") || file.endsWith(".gateway.ts")) &&
      !file.endsWith(".d.ts") &&
      !isExcluded(fullPath)
    ) {
      injectableFiles.push(path.resolve(fullPath));
    }
  }

  return injectableFiles;
}

function generateInjectionFile() {
  const serviceFiles = findInjectableFiles(SERVICES_DIR);
  const opsFiles = findInjectableFiles(OPS_DIR);

  const allFiles = [...serviceFiles, ...opsFiles];

  let imports: string[] = [];
  let registrations: string[] = [];
  let exports: string[] = [];

  registrations.push(
    `import { Container } from './${CONTAINER_RELATIVE_PATH}';`
  );
  registrations.push(`const container = Container.getInstance();`);
  registrations.push("");

  allFiles.forEach((filePath, index) => {
    const relativeImportPath = path
      .relative(path.dirname(OUTPUT_FILE), filePath.replace(/\.ts$/, ""))
      .replace(/\\/g, "/");

    const moduleVar = `module${index}`;
    imports.push(`import * as ${moduleVar} from '${relativeImportPath}';`);

    registrations.push(`Object.values(${moduleVar}).forEach(cls => {`);
    registrations.push(
      `  if (typeof cls === 'function') container.register(cls);`
    );
    registrations.push(`});`);
  });

  exports.push("// Example export: resolve whatever you need manually");
  exports.push("// export const myService = container.resolve(MyService);");

  const fileContent = [
    `// This file is auto-generated by the injection watcher. Do not modify manually.`,
    `// It registers all exported classes with the DI container.`,
    `// Generated on: ${new Date().toISOString()}`,
    "",
    ...imports,
    "",
    ...registrations,
    "",
    ...exports,
    "",
  ].join("\n");

  fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
  fs.writeFileSync(OUTPUT_FILE, fileContent);

  console.log(
    `Generated ${OUTPUT_FILE} with ${allFiles.length} injectable files.`
  );
}

generateInjectionFile();
