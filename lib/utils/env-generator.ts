import * as dotenv from "dotenv";
dotenv.config();

import * as fs from "fs";
import * as path from "path";
import { z, ZodSchema, ZodTypeAny } from "zod";

const ENV_FILE: string = path.resolve(__dirname, "..", "..", ".env");
const OUTPUT_DIR: string = path.resolve(__dirname, "..", "global");
const OUTPUT_FILE_NAME: string = "env.ts";

/**
 * Map Zod types to TypeScript types for type annotation generation.
 */
function zodToTsType(schema: ZodTypeAny): string {
  if (schema instanceof z.ZodString) return "string";
  if (schema instanceof z.ZodNumber) return "number";
  if (schema instanceof z.ZodBoolean) return "boolean";
  if (schema instanceof z.ZodEnum)
    return schema._def.values.map((v: string) => `"${v}"`).join(" | ");
  if (schema instanceof z.ZodLiteral) return JSON.stringify(schema._def.value);
  if (schema instanceof z.ZodDefault) return zodToTsType(schema._def.innerType); // ✅ Handle `.default(...)`
  return "unknown";
}
export function generateEnvConfig<T extends ZodSchema<any>>(schema: T): void {
  console.log("Generating environment configuration...");

  let rawEnvConfig: dotenv.DotenvParseOutput = {};

  try {
    const envContent = fs.readFileSync(ENV_FILE, "utf8");
    rawEnvConfig = dotenv.parse(envContent);
  } catch (error: any) {
    if (error.code === "ENOENT") {
      console.warn(
        `Warning: .env file not found at ${ENV_FILE}. Generating empty env.ts.`
      );
    } else {
      console.error(`Error reading .env file: ${error.message}`);
      return;
    }
  }

  const parseResult = schema.safeParse(rawEnvConfig);
  if (!parseResult.success) {
    console.error("❌ Environment validation failed:");
    console.error(parseResult.error.format());
    throw new Error("Invalid environment variables. See above for details.");
  }

  const validatedEnv = parseResult.data;

  let outputContent = `// This file is auto-generated by env-watcher. Do not edit directly.\n\n`;

  const declarations: string[] = [];
  const exportsList: string[] = [];

  const shape = (schema as unknown as z.ZodObject<any>)._def.shape();

  for (const key in shape) {
    const zodType = shape[key];
    const tsType = zodToTsType(zodType);
    if (tsType === "number") {
      declarations.push(
        `const ${key}: ${tsType} = Number(process.env.${key}!);`
      );
    } else if (tsType === "boolean") {
      declarations.push(
        `const ${key}: ${tsType} = process.env.${key}! === "true";`
      );
    } else {
      declarations.push(`const ${key}: ${tsType} = process.env.${key}!;`);
    }

    exportsList.push(key);
  }

  outputContent += declarations.join("\n") + "\n\n";
  outputContent += `export {\n  ${exportsList.join(",\n  ")}\n};\n`;

  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
    console.log(`Created output directory: ${OUTPUT_DIR}`);
  }

  const outputPath = path.join(OUTPUT_DIR, OUTPUT_FILE_NAME);
  fs.writeFileSync(outputPath, outputContent, "utf8");
  console.log(`✅ Environment configuration generated at: ${outputPath}`);
}
